import os.path
import sys
from tkinter import colorchooser

current_dir = os.path.dirname(os.path.realpath(__file__)) # gets current directory of this module
included = os.path.join(os.path.dirname(current_dir), "included")
useropts = os.path.join(os.path.dirname(current_dir), "useropts")
user_defaults = os.path.join(current_dir, "user_defaults.txt")

included_apps_dirs = [] # create empty list of directories of included apps
included_apps_info = {}
# included_app_info[module] = {'title': 'ex', 'version': '3.8.2', 'author': 'am', 'directory': 'pl\e.py', 'icon': 'icon.png'}
amount_of_included_apps = 0

# do the same, but for useropts
useropts_apps_dirs = []
useropts_apps_info = {}
amount_of_useropts_apps = 0


# Sets up included_apps_dirs (a list of the directories of included apps)
# root is called root_1 to avoid confusion with tkinter root
for root_1, dirs, files in os.walk(included): # scans through every directory/file in "included" folder
    if os.path.dirname(root_1) == (included): # if the root's (directories with things in them) parent is included
        split_list = root_1.split("\\") # create temporary list of this directory's parts (separating by a \)
        if split_list[len(split_list) - 1] not in ["__pycache__"]: # if the last part of this directory is not __pycache__ (autogenerated folder)
            included_apps_dirs.append(root_1) # add the entire directory of this file to included_apps_dir
amount_of_included_apps = len(included_apps_dirs) # sets amount_of_included_apps to the amount of included apps

# Sets up useropts_apps (does same as above for useropts)
for root_1, dirs, files in os.walk(useropts):
    if os.path.dirname(root_1) == (useropts):
        split_list = root_1.split("\\") 
        if split_list[len(split_list) - 1] not in ["__pycache__"]:
            useropts_apps_dirs.append(root_1)
amount_of_useropts_apps = len(useropts_apps_dirs)
del root_1

# Sets up included_apps_info (a dictionary containing information on each included app)
sys.path.append(included) # temporarily adds included to path (to allow import)
for i in range(amount_of_included_apps):
    split_app = included_apps_dirs[i].split("\\") # splits each part of directory
    app_name = split_app[len(split_app) - 1] # app name will be the last folder in that directory

    try:
        exec("import {}".format(app_name)) # imports the module
    except:
        raise Exception("Included module \'{}\' could not be imported correctly.".format(app_name))

    try:
        title = eval("{}.__title__".format(app_name))[:16] # truncates after 16 letters (max length)
    except:
        title = None
    try:
        version = eval("{}.__version__".format(app_name))
    except:
        version = None
    try:
        author = eval("{}.__author__".format(app_name))
    except:
        author = None
    try:
        default_args = eval("{}.default_args".format(app_name))
        temp_default_args = ""
        k = 1
        for key, value in default_args.items(): # turns default_args into a string of values
            if k == 1:
                if k == len(default_args): # there is only one item in list
                    temp_default_args = "{} = {}".format(key, value)
                else: # there is not only one item but currently on first iteration
                    temp_default_args = "{} = {},".format(key, value)
            else: # not on first iteration
                if k == len(default_args): # on last item in list
                    temp_default_args = "{} {} = {}".format(temp_default_args, key, value)
                else: # not on first or last iteration in list
                    temp_default_args = "{} {} = {},".format(temp_default_args, key, value)
            k += 1
        default_args = temp_default_args 
    except:
        default_args = None
    if os.path.isfile(os.path.join(included, app_name, "icon.png")): # checks if included\[module]\icon.png exists
        icon = os.path.join(included, app_name, "icon.png")
    else:
        icon = None

    included_apps_info[app_name] = {'title': str(title), 'version': str(version),
        'author': str(author), 'directory': included_apps_dirs[i],
        'icon': str(icon), 'default_args': str(default_args)}

# Sets up useropts_apps_info (does same as above for useropts)
sys.path.append(useropts)
for i in range(amount_of_useropts_apps):
    split_app = useropts_apps_dirs[i].split("\\")
    app_name = split_app[len(split_app) - 1]

    try:
        exec("import {}".format(app_name))
    except:
        raise Exception("User module \'{}\' could not be imported correctly.".format(app_name))

    try:
        title = eval("{}.__title__".format(app_name))[:16]
    except:
        title = None
    try:
        version = eval("{}.__version__".format(app_name))
    except:
        version = None
    try:
        author = eval("{}.__author__".format(app_name))
    except:
        author = None
    try:
        default_args = eval("{}.default_args".format(app_name))
        temp_default_args = ""
        k = 1
        for key, value in default_args.items():
            if k == 1:
                if k == len(default_args):
                    temp_default_args = "{} = {}".format(key, value)
                else:
                    temp_default_args = "{} = {},".format(key, value)
            else:
                if k == len(default_args):
                    temp_default_args = "{} {} = {}".format(temp_default_args, key, value)
                else:
                    temp_default_args = "{} {} = {},".format(temp_default_args, key, value)
            k += 1
        default_args = temp_default_args
    except:
        default_args = None
    if os.path.isfile(os.path.join(included, app_name, "icon.png")):
        icon = os.path.join(included, app_name, "icon.png")
    else:
        icon = None
    
    useropts_apps_info[app_name] = {'title': str(title), 'version': str(version),
        'author': str(author), 'directory': included_apps_dirs[i],
        'icon': str(icon), 'default_args': str(default_args)}

del split_list, split_app, app_name, i, k, title, version, author, icon, default_args, temp_default_args # cleans up variables


def edit_user_defaults(setting, new): # replaces a setting in user_defaults.txt with new value
    changed = False
    change_to = "{}: {}\n" # default for most settings in the middle of file

    with open(user_defaults, "r+") as file: # opens user_defaults.txt
        lines = file.readlines() # stores all its lines in "lines"
        for i in range(len(lines)): # for each term in lines
            if lines[i].startswith(setting):
                if i + 1 == len(lines): # if is on the last line
                    change_to = "{}: {}" # already a new line on previous line, not needed
                lines[i] = change_to.format(setting, new)
                changed = True
        if not changed:
            if len(lines) == 0: # if user_defaults.txt is empty
                change_to = "{}: {}" # no \n required 
            else:
                change_to = "\n{}: {}" # adds a new line, so requires \n
            lines.append(change_to.format(setting, new)) # adds the new information to lines
        
        file.seek(0) # sets origin to 0 (the start of the file)
        file.truncate() # removes entire document
        file.writelines(lines) # writes new "lines" to file
        file.close() # closes

def get_current(setting): # gets current value of setting based on its name
    with open(user_defaults, "r") as file:
        lines = file.readlines() # adds all lines in user_defaults to "lines"
        for item in lines:
            if item.startswith(setting):
                return item.split()[1] # the line is split into a list, then its value is gotten
    return None # if this does not terminate (the setting does not exist), return None

def recolour(root, style):
    colour = colorchooser.askcolor(title = "Choose background colour", # creates colour picker [rgb, hex]
                        initialcolor = "SystemButtonFace") # initial colour is default system colour
    root.config(background = colour[1]) # sets the background colour to the hex value
    style.configure("TFrame", background = colour[1])
    style.configure("TButton", background = colour[1]) # sets the buttons' background to that colour
    style.configure("TLabel", background = colour[1])

def setup_defaults(root, style):
    # Setup background
    if get_current("background") == None: # if there is no current setting for "background"
        edit_user_defaults("background", "SystemButtonFace") # create it and set it to default
    root.config(background = get_current("background")) # sets actual background to correct colour
    style.configure("TButton", background = get_current("background")) # sets button backgrounds to correct
    style.configure("TLabel", background = get_current("background"))
    style.configure("TFrame", background = get_current("background"))

def reset_all_defaults(root, style):
    os.remove(user_defaults) # removes current user_defaults file
    file = open(user_defaults, "w+") # recreates the file
    file.close() # closes the opened file
    setup_defaults(root, style) # applies defaults

def run_module(module, root, frame):

    # Checks if function will run correctly
    if module not in sys.modules: # checks if the module is currently imported
        raise Exception("Module \'{}\' does not exist.".format(module)) # raises error if not
    try:
        default_args = eval("{}.default_args".format(module)) # checks if default_args exists
    except:
        default_args = {} # sets default_args to empty if it does not exist


    args_string = ""
    current_iteration = 1
    for key, value in default_args.items(): # gets each key and value in default_args term by term
        if args_string == "": # if on first value
            if len(default_args) == current_iteration: # if also on last value
                args_string += "{} = {}".format(key, value)
            else:
                args_string += "{} = {},".format(key, value)
        elif len(default_args) == current_iteration: # if on last value (but not first)
            args_string += " {} = {}".format(key, value)
        else: # if in the middle
            args_string += " {} = {},".format(key, value)
        current_iteration += 1

    try:
        exec("{}.init({})".format(module, args_string)) # executes [module].init([args])
    except:
        if not eval("\"init\" in dir({})".format(module)): # if [module].init() does not exist
            raise Exception("\'{}.init()\' does not exist.".format(module))
        else: # if it does, the arguments are likely to be incorrect
            raise Exception("Could not run \'{}.init({})\'. "
            "Its default arguments may be incorrect".format(module, args_string))
    
    # Clean up defaultEnvironment's frame
    frame.grid_forget()
    frame.destroy()